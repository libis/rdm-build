################################################################################
# This script configures varaibles used in other shell scripts.
################################################################################

# required for bash for loop if no files found
shopt -s nullglob

# Include some sane defaults
. "${SCRIPT_DIR}/default.config"

# Dataverse URL
DATAVERSE_SERVICE_HOST="${DATAVERSE_SERVICE_HOST:-"dataverse"}"
DATAVERSE_SERVICE_PORT_HTTP="${DATAVERSE_SERVICE_PORT_HTTP:-"8080"}"
DATAVERSE_URL="${DATAVERSE_URL:-"http://${DATAVERSE_SERVICE_HOST}:${DATAVERSE_SERVICE_PORT_HTTP}"}"

# Solr URL
SOLR_SERVICE_HOST="${SOLR_SERVICE_HOST:-"solr"}"
SOLR_SERVICE_PORT_HTTP="${SOLR_SERVICE_PORT_HTTP:-"8983"}"
SOLR_URL="${SOLR_URL:-"http://${SOLR_SERVICE_HOST}:${SOLR_SERVICE_PORT_HTTP}"}"

# Check and load secrets
if [ ! -s "${SECRETS_DIR}/db/password" ]; then
  echo "No database password present. Failing."
  exit 126
fi
POSTGRES_PASSWORD=$(cat "${SECRETS_DIR}/db/password")

if [ ! -s "${SECRETS_DIR}/api/key" ]; then
  echo "No API key present. Failing."
  exit 126
fi
API_KEY=$(cat "${SECRETS_DIR}/api/key")

if [ ! -s "${SECRETS_DIR}/api/userskey" ]; then
  echo "No Users API key present. Failing."
  exit 126
fi
API_USERSKEY=$(cat "${SECRETS_DIR}/api/userskey")

# Drop the Postgres credentials into .pgpass
echo "${POSTGRES_SERVER}:*:*:${POSTGRES_USER}:${POSTGRES_PASSWORD}" > ${HOME_DIR}/.pgpass
chmod 0600 ${HOME_DIR}/.pgpass

# Load dataverseAdmin password if present
ADMIN_PASSWORD='admin'
if [ -s "${SECRETS_DIR}/admin/password" ]; then
  ADMIN_PASSWORD=$(cat "${SECRETS_DIR}/admin/password")
fi

############################################################################
# API bash functions start here.                                           #
############################################################################

# Note that the api path to supply is the part AFTER the 'api' part.
# So a path 'info' will result in an API call 'http://<hostname>:<port>/api/info'.

# Check the reply of an API call
################################
# displays the status value in the JSON reply
# or 'FAILED' and the reply itself if status value is not available
check_reply () {
  echo "$REPLY" | jq -rM '.status' 2>/dev/null || echo -e 'FAILED\n' "$REPLY"
}

URL_HEADERS=()

# Generic Dataverse API call method implemented with curl
#########################################################
# Arguments:
# $1    Method (GET/PUT/POST/...)
# $2    api path
# $@:3  other curl args
# Any extra headers added to the URL_HEADERS array will be added to the curl command
# If the API is locked by token, the token will be added automatically
# The API call reply is stored in the REPLY variable
api_call () {
  local xtra_opts=()
  for h in "${URL_HEADERS[@]}"; do
    xtra_opts+=("-H" "$h")
  done

  local url="${DATAVERSE_URL}/api/${2}"
  local X='?' && [[ "$2" =~ \? ]] && X='&'
  [[ "${API_LOCAL:-x}" == "true" ]] || url="${url}${X}unblock-key=${API_KEY}"
  [[ "${API_DEBUG:-x}" == "true" ]] && echo " -- DEBUG: API call: ${1} ${@:3} ${xtra_opts[@]} $url" || true
  REPLY=$(curl -sS -X ${1} "${@:3}" "${xtra_opts[@]}" "$url")
  [[ "${API_DEBUG:-x}" == "true" ]] && echo " -- DEBUG: $REPLY" || true
}

# Higher level Dataverse API call
#################################
# same args as generic API call
# will also process the reply and check if successful
api() {
  api_call "$@"
  local STATUS=$(jq -n "${REPLY}" | jq -r '.status' 2>/dev/null || echo 'ERROR')
  [[ "${STATUS}" == "OK" ]] && return 0
  local MESSAGE=$(jq -n "${REPLY}" | jq -r '.message' 2>/dev/null)
  [[ "${MESSAGE}" == "null" ]] && MESSAGE="${REPLY}"
  echo "      -> API call '${2}' failed: ${MESSAGE}"
  return -1
}

# Dataverse API GET call
########################
# single argument with api path
api_get () {
  api_call GET "$1" 
}

# Dataverse API call for JSON data
##################################
# content type preset to JSON
# Same args as generic API call
json_call () {
  api_call $1 $2 -H "Content-type: application/json" "${@:3}"
}

# Dataverse API post call for JSON data
#######################################
# method argument preset to POST
json_post () {
  json_call POST "$@"
}

# Dataverse API put call for JSON data
######################################
# method argument preset to PUT
json_put () {
  json_call PUT "$@"
}

# Dataverse API delete call for JSON data
#########################################
# method argument preset to DELETE
json_delete () {
  json_call DELETE "$@"
}

# Disable the Dataverse API to create builtin users
###################################################
builtin_disable() {
  echo "Disabling Builtin Users API"
  api DELETE 'admin/settings/BuiltinUsers.KEY'
  echo
}

# Enable the Dataverse API to create builtin users
##################################################
# The special API userskey is required
builtin_enable() {
  echo "Setting Builtin Users Key"
  api PUT 'admin/settings/BuiltinUsers.KEY' -d "${API_USERSKEY}" 
  echo
}

# Protect the Dataverse admin API with a token
##############################################
api_by_token() {
  echo "Protecting admin API with token"
  export API_LOCAL="false"
  api PUT 'admin/settings/:BlockedApiKey' -d "${API_KEY}"
  api PUT 'admin/settings/:BlockedApiPolicy' -d 'unblock-key'
  api PUT 'admin/settings/:BlockedApiEndpoints' -d 'admin,builtin-users'
  echo
}

# Restrict the Dataverse admin API to locahost only
###################################################
api_only_local() {
  echo "Restricting admin API to localhost only"
  api PUT  'admin/settings/:BlockedApiEndpoints' -d 'admin,builtin-users'
  api PUT 'admin/settings/:BlockedApiPolicy' -d 'localhost-only'
  api DELETE 'admin/settings/:BlockedApiKey'
  export API_LOCAL="true"
  echo
}
